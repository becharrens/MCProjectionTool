global protocol LabelledMessages(role a, role b) {
     M(x: int, int) from a to b;
}


global protocol Test1(role a, role b, role c) {
    rec X {
        mchoice {
             U from a to b; continue X;
        } or {
             U from a to c; continue X;
        }
    }
}

global protocol Controller(role input1, role input2, role processing, role routing, role output1, role output2) {
    rec X1 {
        mchoice {
            packet from input1 to processing;
            rec X2 {
                packet from processing to routing;
                mchoice {
                     packet from input1 to processing;
                    mchoice {
                        packet from routing to output1;
                        continue X2;
                    } or {
                        packet from routing to output2;
                        continue X2;
                    }
                } or {
                    packet from input2 to processing;
                    mchoice {
                        packet from routing to output1;
                        continue X2;
                    } or {
                        packet from routing to output2;
                        continue X2;
                    }
                } or {
                    packet from routing to output1;
                    continue X1;
                } or {
                    packet from routing to output2;
                    continue X1;
                }
            }
        } or {
            packet from input2 to processing;
            rec X2 {
                packet from processing to routing;
                mchoice {
                     packet from input1 to processing;
                    mchoice {
                        packet from routing to output1;
                        continue X2;
                    } or {
                        packet from routing to output2;
                        continue X2;
                    }
                } or {
                    packet from input2 to processing;
                    mchoice {
                        packet from routing to output1;
                        continue X2;
                    } or {
                        packet from routing to output2;
                        continue X2;
                    }
                } or {
                    packet from routing to output1;
                    continue X1;
                } or {
                    packet from routing to output2;
                    continue X1;
                }
            }
        }
    }
}


global protocol Invalid(role a, role b, role c) {
    /*
    - 'c' can confuse 1st and 2nd branches
    - Also trace equivalence in 1st/2nd branches
    */
    mchoice {
        U from a to b; U from a to c;
    } or {
        U from a to c; U from c to a; U from b to a;
    } or {
        U from c to a; U from c to b;
    }
}


global protocol LeaderElection(role a, role b, role c, role env) {
    mchoice {
        leader from a to b; leader from a to c; elect from a to env;
    } or {
        leader from b to a; leader from b to c; elect from b to env;
    } or {
        leader from c to a; leader from c to b; elect from c to env;
    }
}

global protocol Recursion(role a, role b) {
    rec X {
        mchoice {
            U from a to b;
        } or {
            continue X;
        }
    }
}

global protocol DoubleRecursion(role a, role b, role c, role d, role e) {
    rec t1 {
        nat from a to b;
        rec t2 {
            mchoice {
                nat from c to e; continue t1;
            } or {
                nat from d to e; continue t1;
            } or {
                nat from e to d; continue t2;
            }
        }
    }
}

global protocol Rec(role a, role b) {
    rec X {
        U from a to b; continue X;
    }
}

global protocol InvalidInternalChoice(role a, role b, role c, role d) {
    mchoice {
        U from a to b;
        U from a to c;
        U from a to d;
        U from c to d;
    } or {
        U from b to a;
        U from a to c;
        U from a to d;
        U from d to c;
    }
}

global protocol KVStoreSeq(role a1, role a2, role b) {
    rec X {
        mchoice {
            lock from a1 to b;
            rec Y1 {
                mchoice {
                    rec Z1 {
                        mchoice {
                            get from a1 to b;
                            val from a1 to b;
                            continue Z1;
                        } or {
                            barrier from a1 to b;
                            continue Y1;
                        }
                    }
                } or {
                    set from a1 to b;
                    continue Y1;
                } or {
                    unlock from a1 to b;
                    continue X;
                }
            }
        } or {
            lock from a2 to b;
            rec Y2 {
                mchoice {
                    rec Z2 {
                        mchoice {
                            get from a2 to b;
                            val from a2 to b;
                            continue Z2;
                        } or {
                            barrier from a2 to b;
                            continue Y2;
                        }
                    }
                } or {
                    set from a2 to b;
                    continue Y2;
                } or {
                    unlock from a2 to b;
                    continue X;
                }
            }
        }
    }
}

global protocol Invalid1(role a, role b, role c) {
    mchoice {
        U from a to b;
    } or {
        U from a to c;
    }
}

global protocol Invalid2(role a, role b, role c) {
    mchoice {
        U from a to b; U from b to c; U from c to a;
    } or {
        U from b to c; U from c to a; U from a to b;
    }
}

global protocol Invalid3(role a, role b, role c) {
    mchoice {
        U from a to b;
        mchoice {
            U from b to c; U from c to a;
        } or {
            U from c to a; U from b to c;
        }
    } or {
        U from b to c;
        mchoice {
            U from c to a; U from a to b;
        } or {
            U from a to b; U from c to a;
        }
    }
}

global protocol Invalid4(role a, role b, role c) {
    mchoice {
        U from a to b; U from b to c; U from c to a;
    } or {
        U from b to c; U from c to a; U from a to b;
    } or {
        U from c to a; U from a to b; U from b to c;
    }
}

global protocol Unmergeable(role a, role b, role c, role d, role e, role f, role g, role h) {
    /* Valid, but cannot be handled */
    mchoice {
        U from e to f; U from g to h; U from a to b; U from a to d; U from a to c;
    } or {
        U from g to h; U from e to f; U from a to b; U from a to c; U from a to d;
    }
}

/* NEED TO ENSURE THIS IS HANDLED */
global protocol InvalidHiddenGAction(role a, role b, role c) {
    mchoice {
        U from a to b; U from a to c;
    } or {
        U from c to b;  U from a to c;
    }
}

global protocol RecBuffer(role p, role c, role b) {
    rec t {
         U from p to b;
        mchoice {
             U from p to b;  U from b to c;  U from b to c; continue t;
        } or {
             U from b to c;  U from p to b;  U from b to c; continue t;
        }
    }
}

global protocol Buffer(role p, role c, role b) {
     U from p to b;
    mchoice {
         U from p to b;  U from b to c;  U from b to c;
    } or {
         U from b to c;  U from p to b;  U from b to c;
    }
}

global protocol GSemantics(role p1, role p2, role q1, role q2) {
    mchoice {
         U from p1 to q1;
        mchoice {
             U from p2 to q2;
        } or {
             U from q2 to p2;
        }
    } or {
         U from q1 to p1;
        mchoice {
             U from p2 to q2;
        } or {
             U from q2 to p2;
        }
    }
}

/* Valid only if directed mchoice is enabled */
global protocol Example212(role p, role q, role r) {
    mchoice {
         L from p to q;  M from r to p;
    } or {
         M from r to p;
        mchoice {
             L from p to q;
        } or {
             N from p to q;
        }
    }
}

global protocol MultipleProducerOneConsumer(role p1, role p2, role cons, role buf) {
    mchoice {
         U from p1 to buf;
        mchoice {
             U from p2 to buf;  U from buf to cons;  U from buf to cons;
        } or {
             U from buf to cons;  U from p2 to buf;  U from buf to cons;
        }
    } or {
         U from p2 to buf;
        mchoice {
             U from p1 to buf;  U from buf to cons;  U from buf to cons;
        } or {
             U from buf to cons;  U from p1 to buf;  U from buf to cons;
        }
    }
}

global protocol Loop1(role a, role b, role c, role d, role e) {
    rec loop {
         nat from a to b;  nat from a to c;  nat from d to e; continue loop;
    }
}

global protocol Loop2(role a, role b, role c, role d, role e) {
    rec loop {
        mchoice {
             nat from a to b;  nat from a to c; continue loop;
        } or {
             nat from d to e; continue loop;
        }
    }
}
/* Basic two participant rule does not suffice */
global protocol TwoParticipantRule1(role a,role b, role c, role d, role e){
    mchoice {
         U from c to d;  U from d to e;
        mchoice {
             U from a to b;  U from c to a;  U from b to d;
        } or {
             U from b to a;  U from a to c;  U from d to b;
        }
    } or {
         U from c to d;  U from d to e;
        mchoice {
             L from a to b;  U from c to a;  U from b to d;
        } or {
             L from b to a;  U from a to c;  U from d to b;
        }
    }
}

global protocol P1(role a, role b, role c, role d) {
    rec t {
         U from a to b;  U from c to d; continue t;
    }
}

global protocol P2(role a, role b, role c, role d, role e) {
    rec t {
         U from a to b;  U from a to c;  U from d to e; continue t;
    }
}
global protocol P3(role a, role b, role c, role d) {
    rec t {
        mchoice {
             U from a to b; continue t;
        } or {
             U from c to d; continue t;
        }
    }
}

global protocol RecTest1(role X, role Y) {
  rec SEND {
    mchoice{
       m from X to Y;
      continue SEND;
    } or {
       n from X to Y;
      rec SEND2 {
         end from X to Y;
        mchoice {
          continue SEND;
        } or {
          continue SEND2;
        }
      }
    }
  }
}

global protocol InvalidInconsistentLabel(role a, role b) {
    mchoice {
        m1() from a to b;
    } or {
        m1(a: int) from a to b;
    }
}

global protocol ValidConsistentLabel(role a, role b) {
    mchoice {
        m1(a: int) from a to b;
    } or {
        m1(a: int) from a to b;
    }
}

global protocol ValidInconsistentLabel(role a, role b) {
    mchoice {
        m1(a: int) from a to b;
        m1() from a to b;
    } or {
        m2(a: int) from a to b;
        m1(a: int) from a to b;
        m1() from a to b;
    }
}