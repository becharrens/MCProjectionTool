
global protocol Test1(role a, role b, role c) {
    rec X {
        choice {
            a->b:U; continue X
        } or {
            a->c:U; continue X
        }
    }
}

global protocol Controller(role input1, role input2, role processing, role routing, role output1, role output2) {
    rec X1 {
        choice {
            input1 -> processing: packet;
            rec X2 {
                processing -> routing: packet;
                choice {
                    input1 -> processing:packet;
                    choice {
                        routing -> output1: packet;
                        continue X2
                    } or {
                        routing -> output2: packet;
                        continue X2
                    }
                } or {
                    input2 -> processing: packet;
                    choice {
                        routing -> output1: packet;
                        continue X2
                    } or {
                        routing -> output2: packet;
                        continue X2
                    }
                } or {
                    routing -> output1: packet;
                    continue X1
                } or {
                    routing -> output2: packet;
                    continue X1
                }
            }
        } or {
            input2 -> processing: packet;
            rec X2 {
                processing -> routing: packet;
                choice {
                    input1 -> processing:packet;
                    choice {
                        routing -> output1: packet;
                        continue X2
                    } or {
                        routing -> output2: packet;
                        continue X2
                    }
                } or {
                    input2 -> processing: packet;
                    choice {
                        routing -> output1: packet;
                        continue X2
                    } or {
                        routing -> output2: packet;
                        continue X2
                    }
                } or {
                    routing -> output1: packet;
                    continue X1
                } or {
                    routing -> output2: packet;
                    continue X1
                }
            }
        }
    }
}


global protocol Invalid(role a, role b, role c) {
    /*
    - 'c' can confuse 1st and 2nd branches
    - Also trace equivalence in 1st/2nd branches
    */
    choice {
        a->b:U; a->c:U; end
    } or {
        a->c:U; c->a:U; b->a:U; end
    } or {
        c->a:U; c->b:U; end
    }
}


global protocol LeaderElection(role a, role b, role c, role env) {
    choice {
        a->b:leader; a->c:leader; a->env:elect; end
    } or {
        b->a:leader; b->c:leader; b->env:elect; end
    } or {
        c->a:leader; c->b:leader; c->env:elect; end
    }
}

global protocol Recursion(role a, role b) {
    rec X {
        choice {
            a->b:U; end
        } or {
            continue X
        }
    }
}

global protocol DoubleRecursion(role a, role b, role c, role d, role e) {
    rec t1 {
        a->b:nat;
        rec t2 {
            choice {
                c->e:nat; continue t1
            } or {
                d->e:nat; continue t1
            } or {
                e->d:nat; continue t2
            }
        }
    }
}

global protocol Rec(role a, role b) {
    rec X {
        a->b:U; continue X
    }
}

global protocol InvalidInternalChoice(role a, role b, role c, role d) {
    choice {
        a->b:U;
        a->c:U;
        a->d:U;
        c->d:U;
        end
    } or {
        b->a:U;
        a->c:U;
        a->d:U;
        d->c:U;
        end
    }
}

global protocol KVStoreSeq(role a1, role a2, role b) {
    rec X {
        choice {
            a1 -> b:lock;
            rec Y1 {
                choice {
                    rec Z1 {
                        choice {
                            a1->b:get;
                            a1->b:val;
                            continue Z1
                        } or {
                            a1->b:barrier;
                            continue Y1
                        }
                    }
                } or {
                    a1->b:set;
                    continue Y1
                } or {
                    a1->b:unlock;
                    continue X
                }
            }
        } or {
            a2 -> b:lock;
            rec Y2 {
                choice {
                    rec Z2 {
                        choice {
                            a2->b:get;
                            a2->b:val;
                            continue Z2
                        } or {
                            a2->b:barrier;
                            continue Y2
                        }
                    }
                } or {
                    a2->b:set;
                    continue Y2
                } or {
                    a2->b:unlock;
                    continue X
                }
            }
        }
    }
}

global protocol InvalidProtocolWhichPassesIdTraceCondIrp(role a, role b, role c, role rp) {
    /* rp is the problematic role */
    end
}

global protocol Invalid1(role a, role b, role c) {
    choice {
        a->b:U; end
    } or {
        a->c:U; end
    }
}

global protocol Invalid2(role a, role b, role c) {
    choice {
        a->b:U; b->c:U; c->a:U; end
    } or {
        b->c:U; c->a:U; a->b:U; end
    }
}

global protocol Valid2(role a, role b, role c) {
    choice {
        a->b:U;
        choice {
            b->c:U; c->a:U; end
        } or {
            c->a:U; b->c:U; end
        }
    } or {
        b->c:U;
        choice {
            c->a:U; a->b:U; end
        } or {
            a->b:U; c->a:U; end
        }
    }
}

global protocol Invalid3(role a, role b, role c) {
    choice {
        a->b:U; b->c:U; c->a:U; end
    } or {
        b->c:U; c->a:U; a->b:U; end
    } or {
        c->a:U; a->b:U; b->c:U; end
    }
}

global protocol Unmergeable(role a, role b, role c, role d, role e, role f, role g, role h) {
    /* But cannot be handled */
    choice {
        e->f:U; g->h:U; a->b:U; a->d:U; a->c:U; end
    } or {
        g->h:U; e->f:U; a->b:U; a->c:U; a->d:U; end
    }
}

/* NEED TO ENSURE THIS IS HANDLED */
global protocol InvalidHiddenGAction(role a, role b, role c) {
    choice {
        a->b:U; a->c:U; end
    } or {
        c->b:U; a->c: U; end
    }
}